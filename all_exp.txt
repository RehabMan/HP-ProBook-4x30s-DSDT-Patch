#Maintained by: RehabMan for: HP Probook 4x30s

# Fix compilation errors

# Fix _T_x compiler reserved errors
into_all all code_regex _T_0 replaceall_matched begin T_0 end;
into_all all code_regex _T_1 replaceall_matched begin T_1 end;
into_all all code_regex _T_2 replaceall_matched begin T_2 end;
into_all all code_regex _T_3 replaceall_matched begin T_3 end;
into_all all code_regex _T_4 replaceall_matched begin T_4 end;
into_all all code_regex _T_5 replaceall_matched begin T_5 end;
into_all all code_regex _T_6 replaceall_matched begin T_6 end;

# Fix parse errors 
into device label GFX0 code_regex If\s\(CondRefOf\s\(FPED\)\)\s*\n\s*\{\s*\n\s*FPED\s\(\)\s*\n\s*\} remove_matched;

# Fix line 2169 2181 compilations errors
into_all all code_regex DWordMemory\s\(ResourceProducer,\sPosDecode,\sMinFixed,\sMaxFixed,\sCacheable,\sReadWrite,\n\s+0x00000000,\s+//\sGranularity\n\s+0x00000000,\s+//\sRange\sMinimum\n\s+0x00000000,\s+//\sRange\sMaximum\n\s+0x00000000,\s+//\sTranslation\sOffset\n\s+0x00000000,\s+//\sLength replace_matched
begin
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,\n
                    0x00000000,         // Granularity\n
                    0x00000000,         // Range Minimum\n
                    0x00000000,         // Range Maximum\n
                    0x01000000,         // Translation Offset\n
                    0x00000001,         // Length\n
end;
into_all all code_regex DWordMemory\s\(ResourceProducer,\sPosDecode,\sMinFixed,\sMaxFixed,\sCacheable,\sReadWrite,\n\s+0x00000000,\s+//\sGranularity\n\s+0x00000000,\s+//\sRange\sMinimum\n\s+0xFEDFFFFF,\s+//\sRange\sMaximum\n\s+0x00000000,\s+//\sTranslation\sOffset\n\s+0x00000000,\s+//\sLength replace_matched
begin
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,\n
                    0x00000000,         // Granularity\n
                    0x00000000,         // Range Minimum\n
                    0xFEDFFFFF,         // Range Maximum\n
                    0x00000000,         // Translation Offset\n
                    0xFEE00000,         // Length\n
end;

# Fix 3 compilation warnings 
#rehabman: These are warnings and not sure if it a good idea to "fix" them...
#into_all all code_regex \\_SB\.F4EV,.0x0500 replaceall_matched begin F4EV, 0xFFFF end;
#into_all all code_regex \\_SB\.BEVT,.0x10 replaceall_matched begin BEVT, 0xFFFF end;

# Fix NBTT compilation error 
#rehabman: These are also warnings, and not necessary to patch
#into_all all code_regex Name\s\(NBTT,\sPackage\s\(0x08\) replaceall_matched
#begin
#Name (NBTT, Package ()
#end;


#   Power fix - uses AppleACPIBatteryManager.kext  instead VoodooBattery
into device label AC insert
begin
Name (_PRW, Package (0x02)\n
            {\n
                0x18, \n
                0x03\n
            })
end;


#    Replace all instances of AC with ADP1
into_all all code_regex \.AC, replaceall_matched begin .ADP1, end;
into all label AC set_label begin ADP1 end;


#   Insert standard DTGP entry
into method label DTGP remove_entry;
into definitionblock code_regex . insert
begin
Method (DTGP, 5, NotSerialized)\n
{\n
    If (LEqual (Arg0, Buffer (0x10)\n
            {\n
                /* 0000 */    0xC6, 0xB7, 0xB5, 0xA0, 0x18, 0x13, 0x1C, 0x44, \n
                /* 0008 */    0xB0, 0xC9, 0xFE, 0x69, 0x5E, 0xAF, 0x94, 0x9B\n
            }))\n
    {\n
        If (LEqual (Arg1, One))\n
        {\n
            If (LEqual (Arg2, Zero))\n
            {\n
                Store (Buffer (One)\n
                    {\n
                        0x03\n
                    }, Arg4)\n
                Return (One)\n
            }\n
            If (LEqual (Arg2, One))\n
            {\n
                Return (One)\n
            }\n
        }\n
    }\n
    Store (Buffer (One)\n
        {\n
            0x00\n
        }, Arg4)\n
    Return (Zero)\n
}
end;


#    EHCI fix  inject  device 0x1C26 into EHC1 
into method label _DSM parent_adr 0x001D0000 remove_entry;
into device name_adr 0x001D0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package ()\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x26, 0x1c, 0x00, 0x00\n
            }, \n
            "built-in", \n
            Buffer (One)\n
            {\n
                0x00\n
            }, \n
            "AAPL,clock-id", \n
            Buffer (One)\n
            {\n
                0x01\n
            }, \n
            "device_type", \n
            Buffer (0x05)\n
            {\n
                "EHCI"\n
            }, \n
            "AAPL,current-available", \n
            0x0834, \n
            "AAPL,current-extra", \n
            0x0898, \n
            "AAPL,current-extra-in-sleep", \n
            0x0640, \n
            "AAPL,device-internal",\n
            0x02,\n
            "AAPL,max-port-current-in-sleep",\n
            0x0834,  \n
            Buffer (One)\n
            {\n
                0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;

#    EHCI fix inject  device 0x1C26 into EHC2
into method label _DSM parent_adr 0x001A0000 remove_entry;
into device name_adr 0x001A0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package ()\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x26, 0x1c, 0x00, 0x00\n
            }, \n
            "built-in", \n
            Buffer (One)\n
            {\n
                0x00\n
            }, \n
            "AAPL,clock-id", \n
            Buffer (One)\n
            {\n
                0x02\n
            }, \n
            "device_type", \n
            Buffer (0x05)\n
            {\n
                "EHCI"\n
            }, \n
            "AAPL,current-available", \n
            0x0834, \n
            "AAPL,current-extra", \n
            0x0898, \n
            "AAPL,current-extra-in-sleep", \n
            0x0640, \n
            "AAPL,device-internal",\n
            0x02,\n
            "AAPL,max-port-current-in-sleep",\n
            0x0834,  \n
            Buffer (One)\n
            {\n
                0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;


#     Enable functions keys
into device name_hid PNP0303 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "AAPL,has-embedded-fn-keys", \n
            Buffer (0x04)\n
            {\n
                0x01, 0x00, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}\n
end;


#   Inject Audio info
into device label HDEF insert
begin
Method (_DSM, 4, NotSerialized)\n
                {\n
                    Store (Package (0x06)\n
                        {\n
                            "hda-gfx", \n
                            Buffer (0x0A)\n
                            {\n
                                "onboard-1"\n
                            }, \n
                            "layout-id", \n 
                            Buffer (0x04)\n
                            {\n
                                0x0C, 0x00, 0x00, 0x00\n
                            }, \n
                            "PinConfigurations", \n
                            Buffer (Zero) {}\n
                        }, Local0)\n
                    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
                    Return (Local0)\n
                }
end;


#     IRQ fix
into device name_hid PNP0000 code_regex IRQNoFlags\s\(\)\n\s+\{(\d+)\} remove_matched;
into device name_hid PNP0100 code_regex IRQNoFlags\s\(\)\n\s+\{(\d+)\} remove_matched;
into device name_hid PNP0B00 code_regex IRQNoFlags\s\(\)\n\s+\{(\d+)\} remove_matched;
into device name_hid PNP0103 code_regex IRQNoFlags\s\(\)\n\s+\{(\d+)\} removeall_matched;
into device name_hid PNP0103 code_regex Name\s\(([^,]+),\sResourceTemplate\s\(\)\n\s+\{((?:.|\n)*)\}\) replace_matched
begin
Name (%1, ResourceTemplate ()\n
                    {\n
                        IRQNoFlags ()\n
                            {0}\n
                        IRQNoFlags ()\n
                            {8}\n
                        IRQNoFlags ()\n
                            {11}\n
                        IRQNoFlags ()\n
                            {15}\n
%2
})
end;


#   LPC fix injects device 0x1C49 HM65
into method label _DSM parent_adr 0x001F0000 remove_entry;
into device name_adr 0x001F0000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x49, 0x1C, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;


#    Rename all instances of GFX0 to IGPU
into_all all code_regex GFX0 replaceall_matched begin IGPU end;
into_all all label GFX0 set_label begin IGPU end;


#   Brightness control fix
into scope label \_SB insert
begin
Device (PNLF)\n
{\n
	Name (_HID, EisaId ("APP0002"))\n
	Name (_CID, "backlight")\n
	Name (_UID, 0x0A)\n
	Name (_STA, 0x0B)\n
}
end;


#   RTC fix
into device name_hid PNP0B00 code_regex (IO\s\((?:\s*[^,]+,\s*(?:\/\/\s.*)?\s*\n)+\s*)(\dx\d+)(,\s*(?:\/\/\s.*)?\s*\n\s*\)) replace_matched begin %10x02%3 end;


#  Shutdown fix
into method label _PTS code_regex_not If\s\(LEqual\s\(Arg0,\s0x05\)\) code_regex ^((?:.|\n)*)$ replace_matched
begin
        If (LEqual (Arg0, 0x05)) {}\n
        Else\n
        {\n
%1
        }
end;


#   SMBUS fix
into method label _DSM parent_adr 0x001F0003 remove_entry;
into device name_adr 0x001F0003 insert
begin
Device (BUS0)\n
                {\n
                    Name (_CID, "smbus")\n
                    Name (_ADR, Zero)\n
                    Device (DVL0)\n
                    {\n
                        Name (_ADR, 0x57)\n
                        Name (_CID, "diagsvault")\n
                        Method (_DSM, 4, NotSerialized)\n
                        {\n
                            Store (Package (0x02)\n
                                {\n
                                    "address", \n
                                    0x57\n
                                }, Local0)\n
                            DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
                            Return (Local0)\n
                        }\n
                    }\n
                }
end;

#    USB sleep fix injects Macbook 8,1 device IDs
into method label _DSM parent_adr 0x001D0001 remove_entry;
into device name_adr 0x001D0001 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x27, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001D0002 remove_entry;
into device name_adr 0x001D0002 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x2c, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001D0003 remove_entry;
into device name_adr 0x001D0003 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x27, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001D0004 remove_entry;
into device name_adr 0x001D0004 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x2c, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001A0001 remove_entry;
into device name_adr 0x001A0001 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x27, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001A0002 remove_entry;
into device name_adr 0x001A0002 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x2c, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;
into method label _DSM parent_adr 0x001A0003 remove_entry;
into device name_adr 0x001A0003 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x02)\n
        {\n
            "device-id", \n
            Buffer (0x04)\n
            {\n
                0x27, 0x1c, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;


#     HPET fix to avoid AppleIntelCPUPowerManagement panic
into method label _STA parent_hid PNP0103 remove_entry;
into device name_hid PNP0103 insert
begin
Method (_STA, 0, NotSerialized)\n
{\n
    Return (0x0F)\n
}
end;
into method label _CRS parent_hid PNP0103 remove_entry;
into device name_hid PNP0103 insert
begin
Method (_CRS, 0, NotSerialized)\n
{\n
    Return (BUF0)\n
}
end;


#   Airport fix works with vanilla IO80211 kext 
into device label WNIC parent_label RP04 replace_content
begin
Name (_ADR, Zero)  // _ADR: Address\n
Method (_PRW, 0, Serialized)  // _PRW: Power Resources for Wake\n
{\n
	Return (^^_PRW)\n
}\n
Method (_DSM, 4, NotSerialized)\n
{\n
    Store (Package (0x0C)\n
        {\n
            "AAPL,slot-name", \n
            Buffer (0x08)\n
            {\n
                "AirPort"\n
            }, \n
            "device-id", \n
            Unicode ("*"), \n
            "device_type", \n
            Buffer (0x08)\n
            {\n
                "AirPort"\n
            }, \n
            "model", \n
             Buffer (0x33)\n
             {\n
                "Atheros 9285 802.11 b/g/n Wireless Network Adapter"\n
             },\n
            "subsystem-id", \n
            Buffer (0x04)\n
            {\n
                0x8F, 0x00, 0x00, 0x00\n
            }, \n
            "subsystem-vendor-id", \n
            Buffer (0x04)\n
            {\n
                0x6B, 0x10, 0x00, 0x00\n
            }\n
        }, Local0)\n
    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
    Return (Local0)\n
}
end;

into all label WNIC set_label begin ARPT end;


# add fan readings and fan control
into device label SMCD remove_entry;
into definitionblock code_regex . insert
begin
Device (SMCD)\n
{\n
	Name (_HID, "FAN00000")  // _HID: Hardware ID\n
	Method (FAN0, 0, Serialized)\n
	{\n
		Store (\_TZ.GFRM (), Local0)\n
		If (LEqual (0x03C4, Local0))\n
		{\n
			Store (Zero, Local0)\n
			Return (Local0)\n
		}\n
		Return (Local0)\n
	}\n
\n
// commented out: just for debugging and experimenting
//
// monitoring additional temperatures\n
//	Method (TDIM, 0, Serialized)  // GFXZ temp\n
//	{\n
//		Divide (Subtract (\_TZ.GFXZ._TMP, 2732), 10,, Local0)\n
//		return (Local0)\n
//	}\n
//	Method (TSYS, 0, Serialized)  // LOCZ temp\n
//	{\n
//		Divide (Subtract (\_TZ.LOCZ._TMP, 2732), 10,, Local0)\n
//		return (Local0)\n
//	}\n
//\n
// for debugging fan control\n
//	Method (TCPP, 0, Serialized)  // Average temp\n
//	{\n
//		Store (FNUM, Local0)\n
//		if (LNotEqual (Local0, 0))\n
//		{\n
//			Store (FSUM, Local1)\n
//			Divide (Local1, Local0,, Local0)\n
//		}\n
//		return (Local0)\n
//	}\n
//	Method (TAMB, 0, Serialized)  // fan counter\n
//	{\n
//		return (FCNT)\n
//	}\n
//\n
	Method (TCPU, 0, Serialized)\n
	{\n
		Acquire (\_SB.PCI0.LPCB.EC0.ECMX, 0xFFFF)\n
		Store (1, \_SB.PCI0.LPCB.EC0.CRZN)\n
		Store (\_SB.PCI0.LPCB.EC0.DTMP, Local0)\n
		Release (\_SB.PCI0.LPCB.EC0.ECMX)\n
		return (Local0)\n
	}\n
\n
// Fan Control Table (pairs of temp, fan control byte)\n
	Name (FTAB, Buffer ()\n
	{\n
		50, 255, 	// 255 is off (really auto, but at low temp it is off)\n
		57, 128, 	// 128 is slowest speed\n
		63, 82,\n
		68, 74,\n
		72, 59,\n
		75, 49,\n
		0xFF, 0 	// last entry must be 0xFF, 0 is max fan speed\n
	})\n
// Table to keep track of past temperatures (to build average)\n
	Name (FHST, Buffer (16) { 0x0, 0, 0, 0, 0x0, 0, 0, 0, 0x0, 0, 0, 0, 0x0, 0, 0, 0 })\n
	Name (FIDX, Zero) 	// current index in buffer above\n
	Name (FNUM, Zero) 	// number of entries in above buffer to count in avg\n
	Name (FSUM, Zero) 	// current sum of entries in buffer\n
// Keeps track of last fan speed set, and counter to set new one\n
	Name (FLST, 0xFF)	// last index for fan control\n
	Name (FCNT, 0)		// count of times it has been "wrong", 0 means no counter\n
	Name (FCTU, 20)		// timeout for changes (fan rpm going up)\n
	Name (FCTD, 40)		// timeout for changes (fan rpm going down)\n
\n
	// Fan control for CPU -- expects to be evaluated 1-per second\n
	Method (FCPU, 0, Serialized)\n
	{\n
		Acquire (\_SB.PCI0.LPCB.EC0.ECMX, 0xFFFF)\n
\n
		// setup fake temperature (this is the key to controlling the fan!)\n
		Store (1, \_SB.PCI0.LPCB.EC0.CRZN)  // select CPU temp\n
		Store (31, \_SB.PCI0.LPCB.EC0.TEMP) // write fake value there (31C)\n
\n
		// get current temp into Local0 for eventual return\n
		// Note: reading from DTMP here instead of TEMP because we wrote\n
		//  a fake temp to TEMP to trick the system into running the fan\n
		//	at a lower speed than it otherwise would.\n
		Store (1, \_SB.PCI0.LPCB.EC0.CRZN)  // select CPU temp\n
		Store (\_SB.PCI0.LPCB.EC0.DTMP, Local0) // Local0 is current temp\n
\n
		// calculate average temperature\n
		Add (Local0, FSUM, Local1)\n
		Store (FIDX, Local2)\n
		Subtract (Local1, DerefOf (Index (FHST, Local2)), Local1)\n
		Store (Local0, Index (FHST, Local2))\n
		Store (Local1, FSUM)  // Local1 is new sum\n
\n
		// adjust current index into temp table\n
		Increment (Local2)\n
		if (LGreaterEqual (Local2, SizeOf(FHST)))\n
			{ Store (0, Local2) }\n
		Store (Local2, FIDX)\n
		// adjust total items collected in temp table\n
		Store (FNUM, Local2)\n
		if (LNotEqual (Local2, SizeOf (FHST)))\n
		{\n
			Increment (Local2)\n
			Store (Local2, FNUM)\n
		}\n
\n
		// Local1 is new sum, Local2 is number of entries in sum\n
		Divide (Local1, Local2,, Local0)  // Local0 is now average temp\n
\n		
		// table based search (use avg temperature to search)\n
		if (LGreater (Local0, 255)) { Store (255, Local0) }\n
		Store (Zero, Local2)\n
		while (LGreater (Local0, DerefOf (Index (FTAB, Local2))))\n
			{ Add (Local2, 2, Local2) }\n
\n
		// calculate difference between current and found index\n
		if (LGreater (Local2, FLST))\n
		{\n
			Subtract(Local2, FLST, Local1)\n
			Store(FCTU, Local4)\n
		}\n
		else\n
		{\n
			Subtract(FLST, Local2, Local1)\n
			Store(FCTD, Local4)\n
		}\n
\n
		// set new fan speed, if necessary\n
		if (LEqual (Local1, 0))\n
		{\n
			// no difference, so leave current fan speed and reset count\n
			Store (0, FCNT)\n
		}\n
		else\n
		{\n
			// there is a difference, start/continue process of changing fan\n
			Store (FCNT, Local3)\n
			Increment (Local3)\n
			Store (Local3, FCNT)\n
\n
			// how long to wait depends on how big the difference\n
			// 20 secs if diff is 2, 5 secs if diff is 4, etc.\n
			Divide (ShiftLeft (Local4, 1), Local1,, Local1)\n
			if (LGreaterEqual (Local3, Local1))\n
			{\n
				// timeout expired, so set new fan speed\n
				Store (Local2, FLST)\n
				Increment (Local2)\n
				Store (DerefOf (Index (FTAB, Local2)), \_SB.PCI0.LPCB.EC0.FTGC)\n
				Store (0, FCNT)\n
			}\n
		}\n
\n
		Release (\_SB.PCI0.LPCB.EC0.ECMX)\n
		return (Local0)  // returns average temp\n
	}\n
}\n
end;


# patch OS checks

into_all all code_regex If\s\(_OSI\s\(\"Windows\s2006\"\)\) replaceall_matched
begin If (LOr (_OSI ("Darwin"), _OSI ("Windows 2006"))) end;

into_all all code_regex If\s\(\\_OSI\s\(\"Windows\s2006\"\)\) replaceall_matched
begin If (LOr (_OSI ("Darwin"), _OSI ("Windows 2006"))) end;

into method label _RMV parent_label SMHC replace_content begin Return (Zero) end;
into method label _RMV parent_label MSHC replace_content begin Return (Zero) end;
into method label _RMV parent_label XDCC replace_content begin Return (Zero) end;
into method label _RMV parent_label I1C replace_content begin Return (Zero) end;


# Convert battery EC info from 16-bit to 8-bit fields...

# Need this utility method B1B2(lowbyte, hibyte)... returns ((hibyte << 8) | lowbyte)
into definitionblock code_regex . insert
begin
Method (B1B2, 2, NotSerialized)\n
{\n
	ShiftLeft (Arg1, 8, Local0)\n
	Or (Arg0, Local0, Local0)\n
	Return (Local0)\n
}\n
end;

# Change EC register declarations from 16-bit to 8-bit
into device label EC0 code_regex BDC,\s+16 replace_matched begin BDC0, 8,\nBDC1, 8 end;
into device label EC0 code_regex BFC,\s+16 replace_matched begin BFC0, 8,\nBFC1, 8 end;
into device label EC0 code_regex BRTE,\s+16 replace_matched begin RTE0, 8,\nRTE1, 8 end;
into device label EC0 code_regex BME,\s+16 replace_matched begin BME0, 8,\nBME1, 8 end;
into device label EC0 code_regex BDV,\s+16 replace_matched begin BDV0, 8,\nBDV1, 8 end;
into device label EC0 code_regex BATE,\s+16 replace_matched begin ATE0, 8,\nATE1, 8 end;
into device label EC0 code_regex BPR,\s+16 replace_matched begin BPR0, 8,\nBPR1, 8 end;
into device label EC0 code_regex BCR,\s+16 replace_matched begin BCR0, 8,\nBCR1, 8 end;
into device label EC0 code_regex BRC,\s+16 replace_matched begin BRC0, 8,\nBRC1, 8 end;
into device label EC0 code_regex BCC,\s+16 replace_matched begin BCC0, 8,\nBCC1, 8 end;
into device label EC0 code_regex BPV,\s+16 replace_matched begin BPV0, 8,\nBPV1, 8 end;
into device label EC0 code_regex BCV1,\s+16 replace_matched begin BCX0, 8,\nBCX1, 8 end;
into device label EC0 code_regex BCV2,\s+16 replace_matched begin BCA0, 8,\nBCA1, 8 end;
into device label EC0 code_regex BCV3,\s+16 replace_matched begin BCB0, 8,\nBCB1, 8 end;
into device label EC0 code_regex BCV4,\s+16 replace_matched begin BCP0, 8,\nBCP1, 8 end;
into device label EC0 code_regex BATF,\s+16 replace_matched begin ATF0, 8,\nATF1, 8 end;
into device label EC0 code_regex MAXC,\s+16 replace_matched begin AXC0, 8,\nAXC1, 8 end;
into device label EC0 code_regex BSTS,\s+16 replace_matched begin BST0, 8,\nBST1, 8 end;
into device label EC0 code_regex BSN,\s+16 replace_matched begin BSN0, 8,\nBSN1, 8 end;
into device label EC0 code_regex BDAT,\s+16 replace_matched begin BDA0, 8,\nBDA1, 8 end;
into device label EC0 code_regex CBT,\s+16 replace_matched begin CBT0, 8,\nCBT1, 8 end;

# Change access (reads) to those registers from 16-bit to 8-bit
into_all method label BTIF code_regex \(BFC, replaceall_matched begin (B1B2 (BFC0, BFC1), end;
into_all method label GBTI code_regex \(BFC, replaceall_matched begin (B1B2 (BFC0, BFC1), end;
into_all method label BTIF code_regex \(BDV, replaceall_matched begin (B1B2 (BDV0, BDV1), end;
into_all method label GBTI code_regex \(BDV, replaceall_matched begin (B1B2 (BDV0, BDV1), end;
into_all method label BTIF code_regex \(BSN, replaceall_matched begin (B1B2 (BSN0, BSN1), end;
into_all method label GBTI code_regex \(BSN, replaceall_matched begin (B1B2 (BSN0, BSN1), end;
into_all method label BTIF code_regex \(BDAT, replaceall_matched begin (B1B2 (BDA0, BDA1), end;
into_all method label GBTI code_regex \(BDAT, replaceall_matched begin (B1B2 (BDA0, BDA1), end;
into_all method label BTST code_regex \(BPR, replaceall_matched begin (B1B2 (BPR0, BPR1), end;
into_all method label GBTI code_regex \(BPR, replaceall_matched begin (B1B2 (BPR0, BPR1), end;
into_all method label BTST code_regex \(BRC, replaceall_matched begin (B1B2 (BRC0, BRC1), end;
into_all method label GBTI code_regex \(BRC, replaceall_matched begin (B1B2 (BRC0, BRC1), end;
into_all method label GBTI code_regex \(BCR, replaceall_matched begin (B1B2 (BCR0, BCR1), end;
into_all method label BTST code_regex \(BPV, replaceall_matched begin (B1B2 (BPV0, BPV1), end;
into_all method label GBTI code_regex \(BPV, replaceall_matched begin (B1B2 (BPV0, BPV1), end;
into_all method label GBTI code_regex \(BDC, replaceall_matched begin (B1B2 (BDC0, BDC1), end;
into_all method label GBTI code_regex \(BME, replaceall_matched begin (B1B2 (BME0, BME1), end;
into_all method label GBTI code_regex \(BCC, replaceall_matched begin (B1B2 (BCC0, BCC1), end;
into_all method label BTIF code_regex \(BCC, replaceall_matched begin (B1B2 (BCC0, BCC1), end;
into_all method label GBTI code_regex \(CBT, replaceall_matched begin (B1B2 (CBT0, CBT1), end;
into_all method label GBTI code_regex \(BSTS, replaceall_matched begin (B1B2 (BST0, BST1), end;
into_all method label GBTI code_regex \(BCV1, replaceall_matched begin (B1B2 (BCX0, BCX1), end;
into_all method label GBTI code_regex \(BCV2, replaceall_matched begin (B1B2 (BCA0, BCA1), end;
into_all method label GBTI code_regex \(BCV3, replaceall_matched begin (B1B2 (BCB0, BCB1), end;
into_all method label GBTI code_regex \(BCV4, replaceall_matched begin (B1B2 (BCP0, BCP1), end;
into_all method label GBTI code_regex \(BRTE, replaceall_matched begin (B1B2 (RTE0, RTE1), end;
into_all method label GBTI code_regex \(BATE, replaceall_matched begin (B1B2 (ATE0, ATE1), end;
into_all method label GBTI code_regex \(BATF, replaceall_matched begin (B1B2 (ATF0, ATF1), end;
into_all method label GBTC code_regex \(MAXC, replaceall_matched begin (B1B2 (AXC0, AXC1), end;

# Now deal with the writes to those registers
# Store (0xFA, MAXC)
into_all method label SBTC code_regex \(0xFA,\sMAXC\) replaceall_matched begin (0xFA, AXC0)\nStore (Zero, AXC1) end;
# Store (Zero, MAXC)
into_all method label SBTC code_regex \(Zero,\sMAXC\) replaceall_matched begin (Zero, AXC0)\nStore (Zero, AXC1) end;
# Store (0x00, MAXC)
into_all method label SBTC code_regex \(0x00,\sMAXC\) replaceall_matched begin (0x00, AXC0)\nStore (0x00, AXC1) end;

# Store (GBSS (BSN, BDAT), BTSN)
# rehabman: this one is buggy...
# (don't blame me, I didn't write it)
# but does demonstrate some bugs also in MacIASL
#into_all method label GBTI code_regex Store\s\(GBSS\s\(BSN,\sBDAT\),\sBTSN\) replaceall_matched begin Store (GBSS (B1B2 (BSN0, BSN1), BDA0), BTSN)\nStore (GBSS (B1B2 (BSN0, BSN1), BDA1), BTSN) end;

# This should match against nothing... if it does, it will cause an error when
# compiling the DSDT, which will clue us in that this patch below needs to change.
into_all method label GBTI code_regex Local7 replaceall_matched begin Error_Local7_IsBeingUsedAlready end;

# Store (GBSS (BSN, BDAT), BTSN)
# (this one is for compatibility with MacIASL)
into_all method label GBTI code_regex Store\s\(GBSS\s\(BSN,\sBDAT\),\sBTSN\) replaceall_matched
begin
Store (GBSS (B1B2 (BSN0, BSN1), B1B2 (BDA0, BDA1)), Local7)\n
Store (Local7, BSN0)\n
Store (ShiftRight (Local7, 8), BSN1)
end;

# Store (GBSS (B1B2 (BSN0, BSN1), BDAT, BTSN)
# (this one is for compatibility with DSDT Editor)
into_all method label GBTI code_regex Store\s\(GBSS\s\(B1B2\s\(BSN0,\sBSN1\),\sBDAT\),\sBTSN\) replaceall_matched
begin
Store (GBSS (B1B2 (BSN0, BSN1), B1B2 (BDA0, BDA1)), Local7)\n
Store (Local7, BSN0)\n
Store (ShiftRight (Local7, 8), BSN1)
end;


# Add cycle count and temperature to battery info method

# 16-bit version
#into method label BTIF code_regex Store\s\(BDAT,\sLocal1\) replace_matched
#begin
#   Store (BDAT, Local1)\n
#   // battery cycle count\n
#   Store (BCC, Index (DerefOf (Index (NBTI, Arg0)), 0x0D))\n
#   // battery temperature\n
#	Store (\\_TZ.GTTP (0x04, 0x05, Zero, Zero, 0x7F), Local2)\n
#	Add (Multiply (Local2, 10), 2732, Local2) // Celsius to .1K\n
#	Store (Local2, Index (DerefOf (Index (NBTI, Arg0)), 0x0E))\n
#end;

# 8-bit version
# (this one is for compatibility with MacIASL)
# Store (BDAT, Local1)
into method label BTIF code_regex Store\s\(BDAT,\sLocal1\) replace_matched
begin
    Store (B1B2 (BDA0, BDA1), Local1)\n
    // battery cycle count\n
    Store (B1B2 (BCC0, BCC1), Index (DerefOf (Index (NBTI, Arg0)), 0x0D))\n
    // battery temperature\n
	Store (\\_TZ.GTTP (0x04, 0x05, Zero, Zero, 0x7F), Local2)\n
	Add (Multiply (Local2, 10), 2732, Local2) // Celsius to .1K\n
	Store (Local2, Index (DerefOf (Index (NBTI, Arg0)), 0x0E))\n
end;

# (this one is for compatibility with DSDT Editor)
# Store (B1B2 (BDA0, BDA1), Local1)
into method label BTIF code_regex Store\s\(B1B2\s\(BDA0,\sBDA1\),\sLocal1\) replace_matched
begin
    Store (B1B2 (BDA0, BDA1), Local1)\n
    // battery cycle count\n
    Store (B1B2 (BCC0, BCC1), Index (DerefOf (Index (NBTI, Arg0)), 0x0D))\n
    // battery temperature\n
	Store (\\_TZ.GTTP (0x04, 0x05, Zero, Zero, 0x7F), Local2)\n
	Add (Multiply (Local2, 10), 2732, Local2) // Celsius to .1K\n
	Store (Local2, Index (DerefOf (Index (NBTI, Arg0)), 0x0E))\n
end;

into all code_regex \"Hewlett\-Packard\"\s+\},\s+Package\s\(0x0D\) replaceall_matched
begin
		"Hewlett-Packard",\n
        Zero,\n
        Zero,\n
   	},\n
	Package (0x0F)\n
end;

into all code_regex Name\s\(NBTI,\sPackage\s\(0x02\)\s+\{\s+Package\s\(0x0D\) replaceall_matched
begin
	Name (NBTI, Package(0x02)\n
	{\n
		Package (0x0F)\n
end;

into_all all code_regex \"LIon\",\s+\"Hewlett\-Packard\"\n\s+\}\n replaceall_matched
begin
	"LIon",\n
	"Hewlett-Packard",\n
	Zero,\n
	Zero,\n
}\n
end;


#   Inject HDMI info into GFX0/IGPU   */
into method label _DSM parent_adr 0x00020000 remove_entry;
into device name_adr 0x00020000 insert
begin
Method (_DSM, 4, NotSerialized)\n
{\n
                    Store (Package (0x04)\n
                        {\n
                            "hda-gfx",\n 
                            Buffer (0x0A)\n
                            {\n
                                "onboard-1"\n
                            },\n 
                            "AAPL,snb-platform-id",\n 
                            Buffer (0x04)\n
                            {\n
                                0x00, 0x00, 0x01, 0x00\n
                            }\n
                        }, Local0)\n
                    DTGP (Arg0, Arg1, Arg2, Arg3, RefOf (Local0))\n
                    Return (Local0)\n 
               }\n
end;

